<!-- WARNING THIS FILE IS AUTOGENERATED BY build_readme.sh DO NOT EDIT -->
APIUtils
========

A handy collection of utility libs for designing apis in go

Codecs
------

Codecs should live seperate to handlers.
The lines between business logic and data encoding should be kept sharp.
The codec package enables this to be done.

e.g. a simple helloworld application

```go
package main

import (
	"net/http"
	"time"

	"github.com/JoeReid/apiutils/render"
	"github.com/JoeReid/apiutils/render/jsoncodec"
	"github.com/JoeReid/apiutils/render/yamlcodec"
)

type HelloEndpoint struct {
	// DB etc...
}

func (h *HelloEndpoint) ServeCodec(c render.Codec, w http.ResponseWriter, r *http.Request) {
	type Hello struct {
		Hello string    `json:"hello" yaml:"yamlhello"`
		Time  time.Time `json:"timestamp" yaml:"yamltimestamp"`
	}

	// Respond back with a simple hello world message
	c.Respond(r.Context(), w, http.StatusOK, &Hello{
		Hello: "world",
		Time:  time.Now(),
	})
}

func main() {
	hello := &HelloEndpoint{}

	http.Handle("/json", render.HandlerWithCodec(jsoncodec.New(), hello))
	http.Handle("/yaml", render.HandlerWithCodec(yamlcodec.New(), hello))
	http.ListenAndServe(":8080", nil)
}
```

### But wait, theres more

Why not let the api consumer decide the format they want

```go
package main

import (
	"net/http"
	"time"

	"github.com/JoeReid/apiutils/render"
	"github.com/JoeReid/apiutils/render/jsoncodec"
	"github.com/JoeReid/apiutils/render/yamlcodec"
)

type HelloEndpoint struct {
	// DB etc...
}

func (h *HelloEndpoint) ServeCodec(c render.Codec, w http.ResponseWriter, r *http.Request) {
	type Hello struct {
		Hello string    `json:"hello" yaml:"yamlhello"`
		Time  time.Time `json:"timestamp" yaml:"yamltimestamp"`
	}

	// Respond back with a simple hello world message
	c.Respond(r.Context(), w, http.StatusOK, &Hello{
		Hello: "world",
		Time:  time.Now(),
	})
}

func main() {
	// configure all the codec options
	codecSelector, _ := render.NewRequestSelector(
		render.RegisterCodec(
			jsoncodec.New(), "json", "application/json"),

		render.RegisterCodec(
			jsoncodec.New(jsoncodec.SetIndent("", "\t")),
			"json,pretty", "application/json,pretty"),

		render.RegisterCodec(
			yamlcodec.New(), "yaml", "application/x-yaml"),
	)

	// serve all the codecs on a common endpoint
	hello := &HelloEndpoint{}
	http.Handle("/hello", render.HandlerWithSelector(codecSelector, hello))
	http.ListenAndServe(":8080", nil)
}
```

Pagination
----------

Write your handler to fetch paginated data, and let the lib wory about
getting the values from the consumer.

```go
package main

import (
	"net/http"

	"github.com/JoeReid/apiutils/paginate"
	"github.com/JoeReid/apiutils/render"
	"github.com/JoeReid/apiutils/render/jsoncodec"
	"github.com/JoeReid/apiutils/render/yamlcodec"
)

type PaginationExample struct {
	// DB etc...
}

func (p *PaginationExample) ServeCodec(c render.Codec, w http.ResponseWriter, r *http.Request) {
	count, skip, err := paginate.Vars(r, paginate.DefaultCount(10), paginate.MaxCount(10))
	if err != nil {
		c.Respond(r.Context(), w, http.StatusBadRequest, err)
		return
	}

	// build a slice of ints to simulate paginated data
	data := make([]int, count)
	for i := 0; i < count; i++ {
		data[i] = (count * skip) + i
	}

	// Respond with this fragment of the data
	c.Respond(r.Context(), w, http.StatusOK, data)
}

func main() {
	// configure all the codec options
	codecSelector, _ := render.NewRequestSelector(
		render.RegisterCodec(jsoncodec.New(), "json", "application/json"),
		render.RegisterCodec(yamlcodec.New(), "yaml", "application/x-yaml"),
	)

	paginate := &PaginationExample{}
	http.Handle("/paginate", render.HandlerWithSelector(codecSelector, paginate))
	http.ListenAndServe(":8080", nil)
}
```
